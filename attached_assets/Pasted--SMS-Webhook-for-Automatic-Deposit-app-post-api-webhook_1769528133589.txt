// SMS Webhook for Automatic Deposit
app.post('/api/webhook/sms', async (req, res) => {
    try {
        // ·ä†·çë ·ã®·àö·àç·ä´·â∏·ãç·äï ·àµ·àû·âΩ ·àò·àà·ã®·âµ
        const from = req.body.from || req.body.sender || req.body.phone;
        const body = req.body.body || req.body.message || req.body.text;

        console.log("----------------------------");
        console.log("[SMS Webhook Raw Data]:", JSON.stringify(req.body));

        // ·ã≥·â≥·ãç ·â£·ã∂ ·ä®·àÜ·äê ·ãà·ã≠·àù ·ä†·çë ·â´·à™·ã´·â•·àâ·äï ·ä´·àç·âÄ·ã®·à®·ãç
        if (!from || !body || from === "%from%" || from === "{{from}}") {
            console.log("[SMS Webhook] Invalid or Empty Data received");
            return res.status(200).json({ success: false, error: "Invalid data" });
        }

        // ·àã·ä™·ãç ·ã®·â∞·çà·âÄ·ã∞ ·àò·àÜ·äë·äï ·âº·ä≠ ·àõ·ãµ·à®·åç
        const allowed = ["127", "0975118009", "+251975118009", "81122", "telebirr", "611"];
        const isAllowed = allowed.some(sender => from.toString().includes(sender));

        if (isAllowed) {
            // Transaction ID ·ä•·äì Amount ·àò·çà·àà·åä·ã´
            const txMatch = body.match(/(?:Transaction ID|·àò·àà·ã´ ·âÅ·å•·à≠|ID|Ref)[:\s]*([A-Z0-9]{8,})/i) || body.match(/([A-Z0-9]{10,})/);
            const amountMatch = body.match(/([\d,]+\.\d{2})\s*(?:·â•·à≠|ETB)/i) || body.match(/(?:amount|·àò·å†·äï)[:\s]*([\d,.]+)/i);

            if (txMatch) {
                const transactionId = txMatch[1].trim();
                const amount = amountMatch ? parseFloat(amountMatch[1].replace(/,/g, '')) : null;

                // ·ã≥·â≥·â§·ãù ·ãç·àµ·å• ·àò·äñ·à©·äï ·àõ·à®·åã·åà·å•
                const existingSms = await pool.query("SELECT id FROM received_sms WHERE transaction_id = $1", [transactionId]);
                if (existingSms.rows.length > 0) return res.sendStatus(200);

                // ·àò·àò·ãù·åà·â•
                await pool.query(
                    "INSERT INTO received_sms (transaction_id, amount, message_text, sender) VALUES ($1, $2, $3, $4)",
                    [transactionId, amount, body, from]
                );

                // ·çî·äï·ã≤·äï·åç ·ã≤·çñ·ãö·âµ ·àò·çà·àà·åç
                const pendingMatch = await pool.query(
                    "SELECT * FROM deposits WHERE confirmation_code = $1 AND status = 'pending'",
                    [transactionId]
                );

                if (pendingMatch.rows.length > 0) {
                    const deposit = pendingMatch.rows[0];
                    const depAmount = parseFloat(deposit.amount);

                    const client = await pool.connect();
                    try {
                        await client.query('BEGIN');
                        await client.query('UPDATE wallets SET deposit_balance = deposit_balance + $1 WHERE user_id = $2', [depAmount, deposit.user_id]);
                        await client.query("UPDATE deposits SET status = 'completed' WHERE id = $1", [deposit.id]);
                        await client.query('COMMIT');

                        // ·â¥·àå·åç·à´·àù ·àõ·à≥·ãà·âÇ·ã´
                        const userResult = await client.query('SELECT telegram_id FROM users WHERE id = $1', [deposit.user_id]);
                        if (bot && userResult.rows[0]?.telegram_id) {
                            const userMsg = `‚úÖ ·ã≤·çñ·ãö·âµ ·â∞·à®·åã·åç·åß·àç!\nüí∞ ·àò·å†·äï: ${depAmount} ETB\nüÜî ID: ${transactionId}`;
                            bot.sendMessage(userResult.rows[0].telegram_id, userMsg);
                        }
                    } catch (e) { await client.query('ROLLBACK'); throw e; } finally { client.release(); }
                }
            }
        }
        res.sendStatus(200);
    } catch (err) {
        console.error('[SMS Webhook] Error:', err);
        res.status(200).json({ success: false });
    }
});